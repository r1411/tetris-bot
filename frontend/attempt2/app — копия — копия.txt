function get(id) {											'Функция получения элемента по ID
  return document.getElementById(id);						'Возвращение элемента из функции
}															'Конец функции
function hide(id) {											'Функция скрытия объекта по id
  get(id).style.visibility = "hidden";						'Изменение видимости объекта на hidden
}															'Конец функции
function show(id) {											'Функция показывания объекта по id
  get(id).style.visibility = null;							'Очищение свойств видимости объекта, что приводит к его показыванию
}															'Конец функции
function html(id, html) {									'Функция вставки html-содержимого в объект по его id
  get(id).innerHTML = html;									'Присвоение html в объект
}															'Конец функции
function timestamp() {										'Функция получения текущего времени
  return new Date().getTime();								'Получение текущего времени
}															'Конец функции
function random(min, max) {									'Функци получения случайного числа в заданном диапазоне
  return min + Math.random() * (max - min);					'Формула рассчета случайного числа между min и max
}															'Конец функции
function randomChoice(choices) {							'Функция выбора случайного элемента из заданного массива
  return choices[Math.round(random(0, choices.length - 1))];'Возвращение случайно выбранного элемента
}															'Конец функции

if (!window.requestAnimationFrame) {						'Если сейчас не требуется анимация
  // http://paulirish.com/2011/requestanimationframe-for-smart-animating/ 'Обращаемся на сторонний  сайт за анимацциями
  window.requestAnimationFrame =							'Обновляем запрос на анимацию окна
    window.webkitRequestAnimationFrame ||					'Запрос на анимацию для работы с webkit
    window.mozRequestAnimationFrame ||						'Или запрос на анимацию для работы в mozila
    window.oRequestAnimationFrame ||						'Или запрос на анимацию для работы в opera
    window.msRequestAnimationFrame ||						'Или запрос на анимацию для работы в microsoft edge
    function (callback, element) {							'Колбэк функция для определения частоты кадров анимации
      window.setTimeout(callback, 1000 / 60);				'Изменение частоты кадров анимации
    };														'Конец функции
}															'Конец условия

// game constants											'Определение игровых констант

var KEY = { ESC: 27, SPACE: 32, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40 }, 'Коды клавиш, участвующих в игре
  DIR = { UP: 0, RIGHT: 1, DOWN: 2, LEFT: 3, MIN: 0, MAX: 3 },			  Кодирование игровых направлений
  stats = new Stats(),										'Создание объекта для отображения игровой статистики
  canvas = get("canvas"),									Получение объекта canvas для отрисовки игровой сцены
  ctx = canvas.getContext("2d"),							Получение поверхности объекта canvas
  ucanvas = get("upcoming"),								Получение объекта для отображения следующей фигурки
  uctx = ucanvas.getContext("2d"),							Получение поверхности объекта для отображения следующей фигурки
  speed = { start: 0.6, decrement: 0.005, min: 0.1 }, // how long before piece drops by 1 row (seconds) Ограничение скорости падения фигурки на один ряд
  nx = 10, // width of tetris court (in blocks)				Определение ширины игрового пространства в тетрис-блоках
  ny = 20, // height of tetris court (in blocks)			Определение высоты игрового пространства в тетрис-блоках
  nu = 5; // width/height of upcoming preview (in blocks)   Ширина и высота окошка для демонстрации следующей фигурки

//-------------------------------------------------------------------------
// game variables (initialized during reset)
//-------------------------------------------------------------------------

var dx,														Размер в пикселях по иксу одного тетрис-блока
  dy, // pixel size of a single tetris block				Размер в пикселях по игрику одного тетрис-блока
  blocks, // 2 dimensional array (nx*ny) representing tetris'Матрица nx*ny представляющая игровое пространство
  actions, // queue of user actions (inputs)				Очередь вводов пользователя
  playing, // true|false - game is in progress				Логическая переменная, показывающая, находится ли сейчас игра в процессе игры
  dt, // time since starting this game						Время от начала текущей игровой сессии
  current, // the current piece								Текущее тетромино
  next, // the next piece									Следующее тетромино
  score, // the current score								Текущий счет игрока
  vscore, // the currently displayed score (it catches up to score in small chunks - like a spinning slot machine) Текущий отображаемый счет (он насчитывается небольшими порциями)
  rows, // number of completed rows in the current game		Количество завершенных линий в текущей игровой сессии
  step; // how long before current piece drops by 1 row    Как долго текущее тетромино падает на один ряд вниз

//-------------------------------------------------------------------------
// tetris pieces
// blocks: each element represents a rotation of the piece (0, 90, 180, 270)
//         each element is a 16 bit integer where the 16 bits represent
//         a 4x4 set of blocks, e.g. j.blocks[0] = 0x44C0
//
//             0100 = 0x4 << 3 = 0x4000
//             0100 = 0x4 << 2 = 0x0400
//             1100 = 0xC << 1 = 0x00C0
//             0000 = 0x0 << 0 = 0x0000
//                               ------
//                               0x44C0
//
//-------------------------------------------------------------------------

var i = {													Определение тетромино "Палка"
  size: 4,													Определение размера тетромино
  blocks: [0x0f00, 0x2222, 0x00f0, 0x4444],					Определение поворотов тетромино
  color: "cyan",											Оределение цвета тетромино этого типа
};															Конец определения тетромино "Палка"
var j = {													Определение тетромино "Конь влево"
  size: 3,													Определение размера тетромино
  blocks: [0x44c0, 0x8e00, 0x6440, 0x0e20],					Определение поворотов тетромино
  color: "blue",											Оределение цвета тетромино этого типа
};															Конец определения тетромино "Конь влево"
var l = {													Определение тетромино "Конь вправо"
  size: 3,													Определение размера тетромино
  blocks: [0x4460, 0x0e80, 0xc440, 0x2e00],					Определение поворотов тетромино
  color: "orange",											Оределение цвета тетромино этого типа
};															Конец определения тетромино "Конь вправо"
var o = {													Определение тетромино "Квадрат"
  size: 2,													Определение размера тетромино
  blocks: [0xcc00, 0xcc00, 0xcc00, 0xcc00],					Определение поворотов тетромино
  color: "yellow",											Оределение цвета тетромино этого типа
};															Конец определения тетромино "Калка"
var s = {													Определение тетромино "Змея вправо"
  size: 3,													Определение размера тетромино
  blocks: [0x06c0, 0x8c40, 0x6c00, 0x4620],					Определение поворотов тетромино
  color: "green",											Оределение цвета тетромино этого типа
};															Конец определения тетромино "Змея вправо"
var t = {													Определение тетромино "Трезубец"
  size: 3,													Определение размера тетромино
  blocks: [0x0e40, 0x4c40, 0x4e00, 0x4640],					Определение поворотов тетромино
  color: "purple",											Оределение цвета тетромино этого типа
};															Конец определения тетромино "Трезубец"
var z = {													Определение тетромино "Змея влево"
  size: 3,													Определение размера тетромино
  blocks: [0x0c60, 0x4c80, 0xc600, 0x2640],					Определение поворотов тетромино
  color: "red",												Оределение цвета тетромино этого типа
};															Конец определения тетромино "Трезубец"

//------------------------------------------------
// do the bit manipulation and iterate through each
// occupied block (x,y) for a given piece
//------------------------------------------------
function eachblock(type, x, y, dir, fn) { 					Функция итерирования по каждому занятому блоку для данного тетромино
  var bit,													Определение переменной итерирования
    result,													Переменная результирования
    row = 0,												Переменная номера строки
    col = 0,												Переменная номера столбца
    blocks = type.blocks[dir];								Определение типов клеток в заданном направлении на игровой матрице
  for (bit = 0x8000; bit > 0; bit = bit >> 1) {				Цикл просмотра всех битов для блока
    if (blocks & bit) {										Если побитовое умножение доступных блоков и текущего = 1, т.е. нет пересечений
      fn(x + col, y + row);									Применить функцию, со смещение на col и row
    }														Конец условия
    if (++col === 4) {										Если у края экрана
      col = 0;												Смещение в нулевую колонку
      ++row;												Изменение ряда 
    }														Конец условия
  }															Конец цикла
}															Конец функции

//-----------------------------------------------------
// check if a piece can fit into a position in the grid
//-----------------------------------------------------
function occupied(type, x, y, dir) {						Функция возможности вставки текущего тетромино в место в игровой матрице
  var result = false;										Логическая переменная результата
  eachblock(type, x, y, dir, function (x, y) {				Вызов функции проверки всего поля
    if (x < 0 || x >= nx || y < 0 || y >= ny || getBlock(x, y)) result = true; Передача в функцию функции, которая осуществляет проверку
  });														Конец усовия и функции
  return result;											Возвращение результата
}															Конец функции

function unoccupied(type, x, y, dir) {						Функция проверки на то, не занято ли место
  return !occupied(type, x, y, dir);						Вызов функции проверки на возможность вставки тетромино
}															Конец функции

//-----------------------------------------
// start with 4 instances of each piece and
// pick randomly until the 'bag is empty'
//-----------------------------------------
var pieces = [];											Определение массива с доступными для игрока детальками, который будет пополняться
function randomPiece() {									Определение функции заполнения массива деталек
  if (pieces.length == 0)									Если массив деталек пустой
    pieces = [												Заполняем массив
      i,													Добавление тетромино "Палка"
      i,													Добавление тетромино "Палка"
      i,													Добавление тетромино "Палка"
      i,													Добавление тетромино "Палка"
      j,													Добавление тетромино "Конь влево"
      j,													Добавление тетромино "Конь влево"
      j,													Добавление тетромино "Конь влево"
      j,													Добавление тетромино "Конь влево"
      l,													Добавление тетромино "Конь вправо"
      l,													Добавление тетромино "Конь вправо"
      l,													Добавление тетромино "Конь вправо"
      l,													Добавление тетромино "Конь вправо"
      o,													Добавление тетромино "Квадрат"
      o,													Добавление тетромино "Квадрат"
      o,													Добавление тетромино "Квадрат"
      o,													Добавление тетромино "Квадрат"
      s,													Добавление тетромино "Змея вправо"
      s,													Добавление тетромино "Змея вправо"
      s,													Добавление тетромино "Змея вправо"
      s,													Добавление тетромино "Змея вправо"
      t,													Добавление тетромино "Трезубец"
      t,													Добавление тетромино "Трезубец"
      t,													Добавление тетромино "Трезубец"
      t,													Добавление тетромино "Трезубец"
      z,													Добавление тетромино "Змея влево"
      z,													Добавление тетромино "Змея влево"
      z,													Добавление тетромино "Змея влево"
      z,													Добавление тетромино "Змея влево"
    ];
  var type = pieces.splice(random(0, pieces.length - 1), 1)[0]; Определение типа первой тетроминошки, которая выйдет из нового массива
  return {													Возвращение объекта
    type: type,												Тип элемента
    dir: DIR.UP,											Направление
    x: Math.round(random(0, nx - type.size)),				Позиция по иксу
    y: 0,													Позиция по игрику
  };														Конец описания объекта
}															Конец функции заполнения

//-------------------------------------------------------------------------
// GAME LOOP
//-------------------------------------------------------------------------

function run() {											Функция запуска игры
  showStats(); // initialize FPS counter					Инициализация счетчика FPS
  addEvents(); // attach keydown and resize events			Связывания клавиш управления и обновление игрового поля

  var last = (now = timestamp());							Определение времени текущей сессии
  function frame() {										Функция отрисовки кадра анимации
    now = timestamp();										Присвоение текущего времени
    update(Math.min(1, (now - last) / 1000.0)); // using requestAnimationFrame have to be able to handle large delta's caused when it 'hibernates' in a background or non-visible tab Вызов функции обновления времени анимаций
    draw();													Вызов функции отрисовки всего игрового пространства
    stats.update();											Вызов функции обновления статистики
    last = now;												Переопределение времени
    requestAnimationFrame(frame, canvas);					Вызов функции для отрисовки анимации
  }															Конец тела функции

  resize(); // setup all our sizing information				Настройка всей изменяемой информации о размерах
  reset(); // reset the per-game variables					Обновление динамических переменных
  frame(); // start the first frame							Начать первый кадр
}															Конец тела функции

function showStats() {										Функция демонастрации счетчика FPS
  stats.domElement.id = "stats";							Изменение id объекта stats
  get("menu").appendChild(stats.domElement);				Присвоение объекта stats в объект с id menu
}															Конец функции

function addEvents() {										Функция связывания клавиш управления
  document.addEventListener("keydown", keydown, false);     Связывание кодов клавиш с нажатием на клавиатуру
  window.addEventListener("resize", resize, false);			Связывание события resize с вызовом функции
}															Конец функции

function resize(event) {									Функция изменения размера игрового окна
  canvas.width = canvas.clientWidth; // set canvas logical size equal to its physical size Установка соответствия логического размера canvas с его физическим
  canvas.height = canvas.clientHeight; // (ditto)			Установка соответствия логического размера canvas с его физическим
  ucanvas.width = ucanvas.clientWidth;						Установка соответствия логического размера uncanvas с его физическим
  ucanvas.height = ucanvas.clientHeight;					Установка соответствия логического размера uncanvas с его физическим
  dx = canvas.width / nx; // pixel size of a single tetris block Определение размера в пикселях одного тетрис-блока по иксу
  dy = canvas.height / ny; // (ditto)						Определение размера в пикселях одного тетрис-блока по игрику
  invalidate();												Вызов функции проверки рендеринга основного блока
  invalidateNext();											Вызов функции проверки рендеринга следующего блока
}															Конец функции

function keydown(ev) {										Функция реагирования на нажатие клавиш
  var handled = false;										Логическая переменная определения: поймали ли мы нажатие
  if (playing) {											Если игра в прогрессе
    switch (ev.keyCode) {									Рассматриваем возможные варианты кодов клавиш
      case KEY.LEFT:										Случай нажатия стрелочки влево
        actions.push(DIR.LEFT);								В очередь действий отправляется движение влево
        handled = true;										Нажатие поймано
        break;												Остановка проверки вариантов кода клавиши нажатия
      case KEY.RIGHT:										Случай нажатия стрелочки вправо
        actions.push(DIR.RIGHT);							В очередь действий отправляется движение вправо
        handled = true;										Нажатие поймано
        break;												Остановка проверки вариантов кода клавиши нажатия
      case KEY.UP:											Случай нажатия стрелочки вверх
        actions.push(DIR.UP);								В очередь действий отправляется поворот
        handled = true;										Нажатие поймано
        break;												Остановка проверки вариантов кода клавиши нажатия
      case KEY.DOWN:										Случай нажатия стрелочки ввниз
        actions.push(DIR.DOWN);								В очередь действий отправляется ускорение падения
        handled = true;										Нажатие поймано
        break;												Остановка проверки вариантов кода клавиши нажатия
      case KEY.ESC:											Случай нажатия кнопки выхода
        lose();												В очередь действий отправляется заканчивание игры
        handled = true;										Нажатие поймано
        break;												Остановка проверки вариантов кода клавиши нажатия
    }														Конец условия
  } else if (ev.keyCode == KEY.SPACE) {						Иначе, если был нажат пробел
    play();													Запустить игру
    handled = true;											Нажатие поймано
  }															Конец условия
  if (handled) ev.preventDefault(); // prevent arrow keys from scrolling the page (supported in IE9+ and all other browsers) Если нажатие поймано, то преградить браузер от скроллинга страницы 
}

//-------------------------------------------------------------------------
// GAME LOGIC
//-------------------------------------------------------------------------

function play() {											Функция начала игры
  hide("start");											Спрятать надпись о том, как начать игру
  reset();													Обновление всего игрового поля и всех настроек
  playing = true;											Логическая переменная активности статуса игры становится истинной
}															Конец функции
function lose() {											Функция проигрыша
  show("start");											Показать надпись о том, как начать игру
  setVisualScore();											Показать итоговый счет
  playing = false;											Логическая переменная активности статуса игры становится ложной
}															Конец функции

function setVisualScore(n) {								Функция установки отображаемого значения
  vscore = n || score;										Хранить в себе одно из двух доступных значений
  invalidateScore();										Рендеринг отображаемого счета
}															Конец функции
function setScore(n) {										Функция установки настоящего счета игрока
  score = n;												Присвоение счета
  setVisualScore(n);										Вызов функции изменения отображаемого счета
}															Конец функции
function addScore(n) {										Функция добавления очков
  score = score + n;										Изменение реального счета игрока
}															Конец функции
function clearScore() {										Функция очистки реального счета игрока
  setScore(0);												Установка значения счета = 0
}															Конец функции
function clearRows() {										Функция очистки количества собранных линий
  setRows(0);												Установка значения = 0
}															Конец функции
function setRows(n) {										Функция установка количества собранных линий
  rows = n;													Количество линий становится равно переданному в функцию
  step = Math.max(speed.min, speed.start - speed.decrement * rows); Изменение переменной скорости шага
  invalidateRows();											Рендеринг количества собранных линий
}															Конец функции
function addRows(n) {										Функция добавления собранных линий
  setRows(rows + n);										Вызов функции установки собранных линий
}															Конец функции
function getBlock(x, y) {									Функция получения блока по координатам
  return blocks && blocks[x] ? blocks[x][y] : null;			Если есть блоки, и есть блоки на строке, то вернуть блоке на строке и столбце, иначе ничего
}															Конец функции
function setBlock(x, y, type) {								Функция изменения блока по координатам и типу
  blocks[x] = blocks[x] || [];								Блоки по иксу это или блоки по иксу или ничего
  blocks[x][y] = type;										Изменение типа блока
  invalidate();												Рендеринг изменений
}															Конец функции
function clearBlocks() {									Функция очистки игрового поля
  blocks = [];												Очистка массива
  invalidate();												Рендеринг изменений
}															Конец функции
function clearActions() {									Функция очистки очереди действий
  actions = [];												Очистка массива действий
}															Конец функции
function setCurrentPiece(piece) {							Функция определения текущего тетромино
  current = piece || randomPiece();							Текущее или равно переданному или берется рандомно
  invalidate();												Отрисовка
}															Конец функции
function setNextPiece(piece) {								Функция определения следующего тетромино
  next = piece || randomPiece();							Следующее или равно переданному или берется рандомно
  invalidateNext();											Рендеринг изменений
}															Конец функции

function reset() {											Функция очистки всех переменных
  dt = 0;													Дельта времени = 0
  clearActions();											Очистка очереди действий
  clearBlocks();											Очистка Игрового поля
  clearRows();												Сброс количества собранных линий
  clearScore();												Сброс полученных очков
  setCurrentPiece(next);									Текущая деталь становится той, что должна была быть дальше
  setNextPiece();											Выбор следующей детали рандомно
}															Конец функции

function update(idt) {										Функция обновления анимаций
  if (playing) {											Если идет игра
    if (vscore < score) setVisualScore(vscore + 1);			Если визуальный счет меньше реального, то добавить единицу к визуальному счету
    handle(actions.shift());								Исполнить следующее действие в очереди
    dt = dt + idt;											Дельта времени = дельта + добавочная дельта
    if (dt > step) {										Если такая дельта больше шага игры
      dt = dt - step;										Дельта = дельта - шаг игры
      drop();												Опустить фигурку
    }														Конец условия
  }															Конец условия
}															Конец функции

function handle(action) {									Функция обработки действия в очереди
  switch (action) {											Проверяем, какое действие было в очереди
    case DIR.LEFT:											Случай движение влево
      move(DIR.LEFT);										Подвинуть тетрамино влево
      break;												Сброс проверки
    case DIR.RIGHT:											Случай движение вправо
      move(DIR.RIGHT);										Подвинуть тетрамино вправо
      break;												Сброс проверки
    case DIR.UP:											Случай поворот детали
      rotate();												Повернуть деталь
      break;												Сброс проверки
    case DIR.DOWN:											Случай ускорить падение
      drop();												Спустить на 1 уровень ниже
      break;												Сброс проверки
  }															Конец проверки
}															Конец функции

function move(dir) {										Функция движения влево-вправо
  var x = current.x,										Координата X текущего тетрамино
    y = current.y;											Координата y текущего тетрамино
  switch (dir) {											Проверка возможного направления движения
    case DIR.RIGHT:											Случай движения направо
      x = x + 1;											Изменяем координату по иксу в плюс
      break;												Сброс проверки
    case DIR.LEFT:											Случай движения налево
      x = x - 1;											Изменяем координату по иксу в минус
      break;												Сброс проверки
    case DIR.DOWN:											Случай движения вниз
      y = y + 1;											Изменяем координату по игрику в плюс
      break;												Сброс проверки
  }															Конец проверки		
  if (unoccupied(current.type, x, y, current.dir)) {		Если с новыми координатами нет занятой ячейки
    current.x = x;											Присваиваем новую координату по иксу
    current.y = y;											Присваиваем новую координату по игрику
    invalidate();											Рендеринг
    return true;											Возвращение истинного значения
  } else {													Случай, если ячейка занята и поставить невозможно
    return false;											Возвращение ложного значения
  }															Конец условия
}															Конец функции

function rotate() {													Поворот Фигурки
  var newdir = current.dir == DIR.MAX ? DIR.MIN : current.dir + 1;	Если текущий поворот - максимальный, то новым будем минимальный, иначе поворот + 1
  if (unoccupied(current.type, current.x, current.y, newdir)) {		Если с такими координатами и новым поворотом ячейки не заняты
    current.dir = newdir;											Изменяем поворот
    invalidate();													Рендеринг изменений
  }																	Конец условия
}															Конец функции

function drop() {											Функция падения вниз
  if (!move(DIR.DOWN)) {									Если уложить фигурку не получается
    addScore(10);											Добавить 10 очков
    dropPiece();											Установка блока
    removeLines();											Убрать линии, если возможно
    setCurrentPiece(next);									Установить новую следующую тетромино
    setNextPiece(randomPiece());							След-следующую установить рандомно
    clearActions();											Очистить очередь действий
    if (occupied(current.type, current.x, current.y, current.dir)) {    Если занято
      lose();															Это проигрыш
    }														Конец условия
  }															Конец условия
}															Конец функции

function dropPiece() {										Функция окончательной установки тетроминошки
  eachblock(current.type, current.x, current.y, current.dir, function (x, y) {	Проверка возможности установки
    setBlock(x, y, current.type);							Установка блока
  });														Конец вложенной функции
}															Конец функции

function removeLines() {									Очистка собранных линий
  var x,													Координата икс
    y,														Координата игрик
    complete,												Логическая переменная проверка завершенности
    n = 0;													Количество собранных линий
  for (y = ny; y > 0; --y) {								Идем снизу вверх по игрику
    complete = true;										Завершенная линия = истина
    for (x = 0; x < nx; ++x) {								Идем слева направо по иксу
      if (!getBlock(x, y)) complete = false;				Если хоть в одном месте отсутствует блок, то заверешенная линия = ложь
    }														Конец цикла
    if (complete) {											Если линия завершена
      removeLine(y);										Удаляем линию по координате
      y = y + 1; // recheck same line						Перепроверяем ту же линию
      n++;													Увеличиваем счетчик количества линий
    }														Конец условия
  }															Конец цикла
  if (n > 0) {												Если счетчик новых линий больше нуля
    addRows(n);												Добавить новые линии в счет игрока
    addScore(100 * Math.pow(2, n - 1)); // 1: 100, 2: 200, 3: 400, 4: 800	Добавить очки игроку
  }															Конец условия
}															Конец функции

function removeLine(n) {									Функция удаления линии по координате
  var x, y;													Переменные координат
  for (y = n; y >= 0; --y) {								Идем по игрику снизу вверху, начиная от удаленной линии
    for (x = 0; x < nx; ++x) setBlock(x, y, y == 0 ? null : getBlock(x, y - 1)); Смещаем все блоки вниз
  }															Конец условия
}															Конец функции

//-------------------------------------------------------------------------
// RENDERING
//-------------------------------------------------------------------------

var invalid = {};											Список неотрендеренных объектов

function invalidate() {										Функция валидации поверхности
  invalid.court = true;										Необходимость рендеринга поверхности
}															Конец функции
function invalidateNext() {									Функци валидации следующей фигурки
  invalid.next = true;										Необходимость рендеринга следующей фигурки
}															Конец функции
function invalidateScore() {								Функция валидации очков игрока
  invalid.score = true;										Необходимость рендеринга счета игрока
}															Конец функции
function invalidateRows() {									Функция валидации количества собранных линий
  invalid.rows = true;										Необходимость рендеринга количества собранных линий
}															Конец функции

function draw() {											Функци отрисовки элементов
  ctx.save();												Сохранение текущего контекста
  ctx.lineWidth = 1;										Установка ширины линий поверхности
  ctx.translate(0.5, 0.5); // for crisp 1px black lines		Небольшое смещение поверхности
  drawCourt();												Отрисовка полученной поверхности
  drawNext();												Отрисовка следующего блока
  drawScore();												Отрисовка счета
  drawRows();												Отрисовка количества линий
  ctx.restore();											Сохранение состояния поверхности
}															Конец функции

function drawCourt() {										Функция отрисовки игровой поверхности
  if (invalid.court) {										Если есть потребность в отрисовке
    ctx.clearRect(0, 0, canvas.width, canvas.height);		Очистить весь канвас
    if (playing)											Если игра в процессе
      drawPiece(ctx, current.type, current.x, current.y, current.dir); Отрисовать текущий блок на канвасе
    var x, y, block;										Описание переменных цикла
    for (y = 0; y < ny; y++) {								Цикл прохода по поверхности сверху вниз
      for (x = 0; x < nx; x++) {							Цикл прохода по поверхности слева на право
        if ((block = getBlock(x, y))) drawBlock(ctx, x, y, block.color); Если блок есть, то рисуем блок
      }														Конец цикла
    }														Конец цикла
    ctx.strokeRect(0, 0, nx * dx - 1, ny * dy - 1); // court boundary Обводка канваса
    invalid.court = false;									Отключение необходимости отрисовки канваса
  }															Конец условия
}															Конец функции

function drawNext() {										Функция отрисовки следующей детальки
  if (invalid.next) {										Если есть потребность в отрисовке следующей детальки
    var padding = (nu - next.type.size) / 2; // half-arsed attempt at centering next piece display Определение смещения для центрирования элемента
    uctx.save();											Сохранение канваса
    uctx.translate(0.5, 0.5);								Небольшое смещение поверхности
    uctx.clearRect(0, 0, nu * dx, nu * dy);					Очистка поверхности
    drawPiece(uctx, next.type, padding, padding, next.dir);	Отрисовка следующей детальки
    uctx.strokeStyle = "black";								Изменение цвета границ на черный		
    uctx.strokeRect(0, 0, nu * dx - 1, nu * dy - 1);		Смещение поверхности
    uctx.restore();											Сохранение текущего состояния поверхности
    invalid.next = false;									Отключение необходимости отрисовки следующей детальки
  }															Конец условия
}															Конец функции

function drawScore() {										Функция отрисовки конечного счета игрока
  if (invalid.score) {										Если есть потребность в отрисовке
    html("score", ("00000" + Math.floor(vscore)).slice(-5));Изменнеие html-составляющей элемента с подсчетом очков
    invalid.score = false;									Отключение потребности в необходимости отрисовки
  }															Конец условия
}															Конец функции

function drawRows() {										Функция отрисовки количества собранных линий
  if (invalid.rows) {										Если есть потребность в отрисовке количества собраных линий
    html("rows", rows);										Изменений html-составляющей элемента с количеством линий
    invalid.rows = false;									Отключение потребности в отрисовке количества линий
  }															Конец условия
}															Конец функции

function drawPiece(ctx, type, x, y, dir) {					Функция отрисовки тетроминошки
  eachblock(type, x, y, dir, function (x, y) {				Просмотр каждого блока
    drawBlock(ctx, x, y, type.color);						Отрисовка конкретного тетромино
  });														Конец условия
}															Конец функции

function drawBlock(ctx, x, y, color) {						Функция отрисовки конкретного блока тетроминошки
  ctx.fillStyle = color;									Определение цвета блока
  ctx.fillRect(x * dx, y * dy, dx, dy);						Заливка блока
  ctx.strokeRect(x * dx, y * dy, dx, dy);					Отрисовка с границами
}															Конец функции

//-------------------------------------------------------------------------
// FINALLY, lets run the game
//-------------------------------------------------------------------------

run();														Запуск игры
